var fs = require("fs");
var soap = require("soap");
var util = require("util");

var options = {
  wsdl : "./test-wsdl/device_service.wsdl",
  output : "./test-output/device_service.js",
  ignoredTypes : "[NetworkZeroConfigurationExtension,Transport]",
  tab : "  ",
  lineEnd : "\n",
  maxdepth : "25",
  throwFaults : "true"
};

args = process.argv.slice(2);
for (var o = 0; o < args.length; o++) {
  var a = args[o].split("=");
  options[a[0]] = a[1];
}

if (!options) {
  console.log("no options provided");
  process.exit(1);
}

if (!options.wsdl) {
  console.log("no options.wsdl path provided");
  process.exit(1);
}
if (!options.output) {
  console.log("no options.output path provided");
  process.exit(1);
}
if (options.ignoredTypes[0] == "[" && options.ignoredTypes[options.ignoredTypes.length - 1] == "]") {
  var it = options.ignoredTypes.substr(1, options.ignoredTypes.length - 2);
  it = it.split(",");
  options.ignoredTypes = util.format("[\"%s\"]", it.join("\",\""));
} else if (options.ignoredTypes) {
  console.log("options.ignoredTypes should be an array");
  process.exit(1);
}

var wsdlPath = options.wsdl;
var outputPath = options.output;
var tab = options.tab || "  ";
var lineEnd = options.lineEnd || "\n";
var ignoredTypes = JSON.parse((options.ignoredTypes || "[]"));
var maxdepth = parseInt(options.maxdepth || "25");
var throwFauls = (options.throwFaults || "true").toLocaleLowerCase() == "true";

console.log("loading wsdl: %s", wsdlPath);
var WSDL = new soap.WSDL(fs.readFileSync(wsdlPath, 'utf8'), wsdlPath, {});

WSDL.onReady(function () {
  var code = ["// This file is generated by the 'node-soap-servicegenerator'", lineEnd,
              "// visit : https://github.com/BreeeZe/node-soap-servicegenerator for more info", lineEnd, lineEnd,
              "var NOT_IMPLEMENTED = {", lineEnd,
              tab, "Fault: {", lineEnd,
              tab, tab, "Code: {", lineEnd,
              tab, tab, tab, "Value: \"soap:client\"", lineEnd,
              tab, tab, "},", lineEnd,
              tab, tab, "Reason: {", lineEnd,
              tab, tab, tab, "Text: \"Method not implemented\"", lineEnd,
              tab, tab, "}", lineEnd,
              tab, "}", lineEnd,
              "};", lineEnd,
              "var exports = module.exports = {};",lineEnd,lineEnd].join('');
  
  console.log("wsdl loaded");
  for (var serviceName in WSDL.services)
    code += generateService(serviceName, WSDL.services[serviceName], tab);
  
  console.log("Writing to : %s", outputPath);
  fs.writeFile(outputPath, code, function (err) {
    if (err) {
      console.log(err);
      process.exit(1);
    }
    console.log('Done!, press any key to exit');
    var stdin = process.openStdin();
    stdin.setRawMode(true);
    stdin.resume();
    stdin.on('data', function (key) {
      process.exit(0);
    });
  });
});

var generateService = function (name, service, indent) {
  var code = "";
  console.log("Generating %s", name);
  for (var portName in service.ports)
    code += generatePort(portName, service.ports[portName], indent + tab);
  
  return util.format(["exports.%s = {", lineEnd,
                       indent, "%s : {", lineEnd,
                       "%s",
                       indent, "}", lineEnd,
                       "}", lineEnd].join(''), name, name , code);
}

var generatePort = function (name, port, indent) {
  var code = "";
  for (var methodName in port.binding.methods)
    code += generateMethod(methodName, port.binding.methods[methodName], indent + tab);
  
  return util.format([indent, "%s : {", lineEnd,
                       "%s",
                       indent, "}", lineEnd].join('') , name, code);
}

var generateMethod = function (name, method, indent) {
  var inputParameter = generateParameter(method.input.$name, method.input, indent + "//", 0);
  var outputParameter = generateParameter(method.output.$name, method.output, indent + tab + "//", 0);
  return util.format([indent, "//", "%s", lineEnd,
                       indent, "%s : function(args /*, cb, headers*/) {", lineEnd,
                       (throwFauls ? 
                         [indent, tab, "throw NOT_IMPLEMENTED;", lineEnd].join('') : 
                         ""),
                       indent, tab, "//", "%s", lineEnd,
                       indent, tab, "//", "return %s;", lineEnd,
                       indent, "},", lineEnd, lineEnd].join(''), inputParameter, name, outputParameter, method.output.$name);
}

var generateParameter = function (name, object, indent, depth) {
  var parameter = [];
  var child, c = 0;
  while (child = object.children[c++]) {
    if (child.name == "complexType") {
      var par = generateType(child, tab + indent, depth);
      if (par)
        parameter.push(par);
    }
    else {
      console.log("Parameter '%s' not a complexType?", name);
      parameter.push[name + " : " + child.name];
    }
  }
  
  var r = util.format(
    ["var %s = { %s};"].join(''), 
        name, 
        (parameter.length > 0 ? 
        [parameter.join("," + lineEnd), lineEnd, indent].join('') : 
        "")
  );
  return r;
};

var generateAttribute = function (object, indent, depth) {
  var name = object.$name;
  var props = [object.$type];
  
  return util.format(
    [indent, "%s : {%s}"].join(''), 
        name,
        props.join("")
  );
};

var generateType = function (object, indent, depth) {
  var props = [];
  var name = "";
  
  var attr = [];
  var child, c = 0;
  while (child = object.children[c++]) {
    if (child.name == "sequence") {
      var el, e = 0;
      while (el = child.children[e++]) {
        var gel = generateElement(el, indent, depth);
        if (gel)
          props.push(gel);
      }
    }
    else if (child.name == "attribute") {
      var gat = generateAttribute(child, tab + indent, depth);
      if (gat)
        attr.push(gat);
    }
    else if (child.name == "complexContent") {
      return generateComplextContent(child, indent, depth);
    }
    else if (child.name == "anyAttribute") { }
    else if (child.name == "annotation") { }
    else if (child.name == "extension") { }
    else if (child.name == "simpleContent") {
      var gsc = generateSimpleContent(child, indent, depth);
      if (gsc)
        props.push(gsc);
    }
    else {
      props.push[child];
    }
  }
  var r = util.format(
    ["%s%s"].join(''), 
        (attr.length ? 
            [lineEnd, indent, "attributes : {", lineEnd, attr.join(',' + lineEnd), lineEnd, indent, "}", (props.length > 0 ? "," : "")].join('') 
            : ""),
        (props.length > 0 ? 
            [lineEnd, props.join("," + lineEnd), lineEnd, indent.substr(tab.length)].join('') : 
            (attr.length ? [lineEnd, indent.substr(2)].join('') : ""))
  );
  return r;
};

var generateSimpleContent = function (object, indent, depth) {
  var res = "";
  var child, c = 0;
  while (child = object.children[c++]) {
    if (child.name == "extension") {
      if (child.$base) {
        var t = child.$base.split(':');
        var typedObject = findChildObjectFromSchema(t[1], WSDL.definitions.xmlns[t[0]]);
        if (typedObject) {
          if (typedObject.name == "complexType")
            res += generateType(typedObject, indent, depth);
          else if (typedObject.name == "simpleType")
            res += generateSimpleType(typedObject, indent, depth);
          else if (typedObject.name == "complexContent")
            res += generateComplextContent(typedObject, indent, depth);
          else if (object.name == "element")
            res += typedObject.$type;
          else
            res += typedObject.name;
        } else {
          res += [indent, child.$base].join('');
        }
        var cchild, cc = 0;
        while (cchild = object.children[cc++]) {
          res += generateType(cchild, indent, depth);
        }
      }
    }
  }
  return res;
};

var generateComplextContent = function (object, indent, depth) {
  var res = "";
  var child, c = 0;
  while (child = object.children[c++]) {
    if (child.name == "extension") {
      if (child.$base) {
        var t = child.$base.split(':');
        var typedObject = findChildObjectFromSchema(t[1], WSDL.definitions.xmlns[t[0]]) || object;
        if (typedObject.name == "complexType")
          res += generateType(typedObject, indent, depth);
        else if (typedObject.name == "simpleType")
          res += generateSimpleType(typedObject, indent, depth);
        else if (typedObject.name == "complexContent")
          res += generateComplextContent(typedObject, indent, depth);
        else if (object.name == "element")
          res += typedObject.$type;
        else
          res += typedObject.name;
      }
      res += generateType(child, indent, depth);
    }
  }
  res += generateType(object, indent, depth);
  return res;
};

var generateSimpleType = function (object, indent, depth) {
  var child, c = 0;
  while (child = object.children[c++]) {
    if (child.name == "restriction")
      return child.$base || child.$type;
    else if (child.name == "list") {
      return ["[", child.$itemType, "]"].join('');
    }
  }
  return object.name;
};

var generateElement = function (object, indent, depth) {
  var org = object;
  depth++;
  if (object.$type && ignoredTypes.indexOf(object.$type.split(':')[1]) > -1)
    return "";
  if (depth > maxdepth) {
    console.log("ABORT !! Maxdepth exceeded on generating : %s type %s", object.$name, object.$type);
    process.exit(-1);
  }
  var res;
  var name = object.$name;
  if (object.$type) {
    var t = object.$type.split(':');
    object = findChildObjectFromSchema(t[1], WSDL.definitions.xmlns[t[0]]) || object;
  }
  
  if (object) {
    if (object.name == "complexType")
      res = generateType(object, tab + indent, depth);
    else if (object.name == "simpleType")
      res = generateSimpleType(object, tab + indent, depth);
    else if (object.name == "complexContent")
      res = generateComplextContent(object, tab + indent, depth);
    else if (object.name == "simpleContent")
      res = generateSimpleContent(object, tab + indent, depth);
    else if (object.name == "element")
      res = object.$type;
    else if (object.name == "any")
      res = "";
    else
      res = object.name;
  }
  if (name) {
    var r = util.format(
      [indent, "%s : %s{ %s}%s"].join(''), 
        name,
        (org.$minOccurs && org.$maxOccurs ? "[" : ""),
        (res? res : ""),
        (org.$minOccurs && org.$maxOccurs ? "]" : "")
    );
    return r;
  }
};

var findChildObjectFromSchema = function (name, xmlns) {
  if (!WSDL.definitions.schemas || !name || !xmlns) {
    return null;
  }
  
  var schema = WSDL.definitions.schemas[xmlns];
  if (!schema || !schema.complexTypes) {
    return null;
  }
  
  return schema.complexTypes[name] || schema.types[name];
};
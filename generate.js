var fs = require("fs");
var soap = require("soap");
var util = require("util");

var options = {
    wsdl : "./test-wsdl/device_service.wsdl",
    output : "./test-output/device_service.js",
    ignoredTypes : "[NetworkZeroConfigurationExtension,Transport]",
    tab : "    ",
    maxdepth : "25",
    throwFaults : "true"
};

args = process.argv.slice(2);
for (var o = 0; o < args.length; o++) {
    var a = args[o].split("=");
    options[a[0]] = a[1];
}

if (!options) {
    console.log("no options provided");
    process.exit(1);
}

if (!options.wsdl) {
    console.log("no options.wsdl path provided");
    process.exit(1);
}
if (!options.output) {
    console.log("no options.output path provided");
    process.exit(1);
}
if (options.ignoredTypes[0] == "[" && options.ignoredTypes[options.ignoredTypes.length - 1] == "]") {
    var it = options.ignoredTypes.substr(1, options.ignoredTypes.length - 2);
    it = it.split(",");
    options.ignoredTypes = util.format("[\"%s\"]", it.join("\",\""));
} else if (options.ignoredTypes) {
    console.log("options.ignoredTypes should be an array");
    process.exit(1);
}

var wsdlPath = options.wsdl;
var outputPath = options.output;
var tab = options.tab || "    ";
var ignoredTypes = JSON.parse((options.ignoredTypes || "[]"));
var maxdepth = parseInt(options.maxdepth || "25");
var throwFauls = (options.throwFaults || "true").toLocaleLowerCase() == "true";

console.log("loading wsdl: %s", wsdlPath);
var WSDL = new soap.WSDL(fs.readFileSync(wsdlPath, 'utf8'), wsdlPath, {});

WSDL.onReady(function () {
    var code = ["// This file is generated by the 'node-soap-servicegenerator'\r\n",
                "// visit : https://github.com/BreeeZe/node-soap-servicegenerator for more info\r\n\r\n"].join('');
    
    console.log("wsdl loaded");
    for (var serviceName in WSDL.services)
        code += generateService(serviceName, WSDL.services[serviceName], tab);
    
    console.log("Writing to : %s", outputPath);
    fs.writeFile(outputPath, code, function (err) {
        if (err) {
            console.log(err);
            process.exit(1);
        }
        console.log('Done!, press any key to exit');
        var stdin = process.openStdin();
        stdin.setRawMode(true);
        stdin.resume();
        stdin.on('data', function (key) {
            process.exit(0);
        });
    });
});

var generateService = function (name, service, indent) {
    var code = "";
    console.log("Generating %s", name);
    for (var portName in service.ports)
        code += generatePort(portName, service.ports[portName], indent + tab);
    
    return util.format(["var %s = {\r\n",
                       indent, "%s : {\r\n",
                       "%s",
                       indent, "}\r\n",
                       "}\r\n"].join(''), name, name , code);
}

var generatePort = function (name, port, indent) {
    var code = "";
    for (var methodName in port.binding.methods)
        code += generateMethod(methodName, port.binding.methods[methodName], indent + tab);
    
    return util.format([indent, "%s : {\r\n",
                       "%s",
                       indent, "}\r\n"].join('') , name, code);
}

var generateMethod = function (name, method, indent) {
    var inputParameter = generateParameter(method.input.$name, method.input, "//" + indent, 0);
    var outputParameter = generateParameter(method.output.$name, method.output, "//" + indent + tab, 0);
    return util.format(["//", indent, "%s\r\n",
                       indent, "%s : function(args /*, cb, headers*/) {\r\n",
                       (throwFauls ? indent + tab + "throw { Fault: { Code: { Value: \"soap:client\" }, Reason: { Text: \"Method not implemented\" } } };\r\n" : ""),
                       "//", indent, "%s\r\n",
                       "//", indent, tab, "return %s;\r\n",
                       indent, "},\r\n\r\n"].join(''), inputParameter, name, outputParameter, method.output.$name);
}

var generateParameter = function (name, object, indent, depth) {
    var parameter = [];
    var child, c = 0;
    while (child = object.children[c++]) {
        if (child.name == "complexType") {
            var par = generateComplexType(child, indent + tab, depth);
            if (par)
                parameter.push(par);
        }
        else {
            console.log("Parameter '%s' not a complexType?", name);
            parameter.push[name + " : " + child.name];
        }
    }
    
    var r = util.format(
        ["var %s = { %s};"].join(''), 
        name, 
        (parameter.length > 0 ? 
        [parameter.join(",\r\n"), "\r\n", indent].join('') : 
        "")
    );
    return r;
};

var generateAttribute = function (object, indent, depth) {
    var name = object.$name;
    var props = [object.$type];
    
    return util.format(
        [indent, "%s : {%s}"].join(''), 
        name,
        props.join("")
    );
};

var generateComplexType = function (object, indent, depth) {
    var props = [];
    var name = "";
    
    var attr = [];
    var child, c = 0;
    while (child = object.children[c++]) {
        if (child.name == "sequence") {
            var el, e = 0;
            while (el = child.children[e++]) {
                var gel = generateElement(el, indent,depth);
                if (gel)
                    props.push(gel);
            }
        }
        else if (child.name == "attribute") {
            var gat = generateAttribute(child, indent + tab, depth);
            if (gat)
                attr.push(gat);
        }
        else if (child.name == "complexContent") {
            var gcc = generateComplextContent(child, indent, depth);
            if (gcc)
                props.push(gcc);
        }
        else if (child.name == "anyAttribute") { }
        else if (child.name == "annotation") { }
        else if (child.name == "extension") { }
        else {
            props.push[child];
        }
    }
    var r = util.format(
        ["%s%s"].join(''), 
        (attr.length ? 
            ["\r\n", indent, "attributes : {\r\n", attr.join(',\r\n'), "\r\n", indent, "}", (props.length > 0 ? "," : "")].join('') 
            : ""),
        (props.length > 0 ? 
            ["\r\n", props.join(",\r\n"), "\r\n", indent.substr(0, indent.length - tab.length)].join('') : 
            "")
    );
    return r;
};

var generateComplextContent = function (object, indent, depth) {
    var res = "";
    var child, c = 0;
    while (child = object.children[c++]) {
        if (child.name == "extension") {
            if (child.$base) {
                var t = child.$base.split(':');
                var typedObject = findChildObjectFromSchema(t[1], WSDL.definitions.xmlns[t[0]]) || object;
                if (typedObject.name == "complexType")
                    res += generateComplexType(typedObject, indent, depth);
                else if (typedObject.name == "simpleType")
                    res += generateSimpleType(typedObject, indent, depth);
                else if (typedObject.name == "complexContent")
                    res += generateComplextContent(typedObject, indent, depth);
                else if (object.name == "element")
                    res += typedObject.$type;
                else
                    res += typedObject.name;
            }
        }
    }
    res += generateComplexType(object, indent, depth);
    return res;
};

var generateSimpleType = function (object, indent, depth) {
    var child, c = 0;
    while (child = object.children[c++]) {
        if (child.name == "restriction")
            return child.$base || child.$type;
    }
    return object.name;
};

var generateElement = function (object, indent, depth) {
    depth++;
    if (object.$type && ignoredTypes.indexOf(object.$type.split(':')[1]) > -1)
        return "";
    if (depth > maxdepth) {
        console.log("ABORT !! Maxdepth exceeded on generating : %s type %s", object.$name, object.$type);
        process.exit(-1);
    }
    var res;
    var name = object.$name;
    if (object.$type) {
        var t = object.$type.split(':');
        object = findChildObjectFromSchema(t[1], WSDL.definitions.xmlns[t[0]]) || object;
    }
    
    if (object) {
        if (object.name == "complexType")
            res = generateComplexType(object, indent + tab, depth);
        else if (object.name == "simpleType")
            res = generateSimpleType(object, indent + tab, depth);
        else if (object.name == "complexContent")
            res = generateComplextContent(object, indent + tab, depth);
        else if (object.name == "element")
            res = object.$type;
        else
            res = object.name;
    }
    if (name) {
        var r = util.format(
            [indent, "%s : { %s}"].join(''), 
        name,
        (res? res : "")
        );
        return r;
    }
};

var findChildObjectFromSchema = function (name, xmlns) {
    if (!WSDL.definitions.schemas || !name || !xmlns) {
        return null;
    }
    
    var schema = WSDL.definitions.schemas[xmlns];
    if (!schema || !schema.complexTypes) {
        return null;
    }
    
    return schema.complexTypes[name] || schema.types[name];
};
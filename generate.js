var fs = require("fs");
var soap = require("soap");
var util = require("util");

var options = {
    wsdl : "./test-wsdl/device_service.wsdl",
    output : "./test-output/device_service.js",
    ignoredTypes : "[NetworkZeroConfigurationExtension]",
    tab : "    ",
    maxrecursion : 25
};

args = process.argv.slice(2);
for (var o = 0; o < args.length; o++) {
    var a = args[o].split("=");
    options[a[0]] = a[1];
}

if (!options) {
    console.log("no options provided");
    process.exit(1);
}

if (!options.wsdl) {
    console.log("no options.wsdl path provided");
    process.exit(1);
}
if (!options.output) {
    console.log("no options.output path provided");
    process.exit(1);
}
if (options.ignoredTypes[0] == "[" && options.ignoredTypes[options.ignoredTypes.length - 1] == "]") {
    var it = options.ignoredTypes.substr(1, options.ignoredTypes.length - 2);
    it=it.split(",");
    options.ignoredTypes = util.format("[\"%s\"]", it.join("\""));
} else if (options.ignoredTypes) {
    console.log("options.ignoredTypes should be an array");
    process.exit(1);
}

var wsdlPath = options.wsdl;
var outputPath = options.output;
var tab = options.tab || "    ";
var ignoredTypes = JSON.parse((options.ignoredTypes || "[]"));
var maxrecursion = options.maxrecursion || 25;

console.log("loading wsdl: %s", wsdlPath);
var WSDL = new soap.WSDL(fs.readFileSync(wsdlPath, 'utf8'), wsdlPath, {});

WSDL.onReady(function () {
    var code = ["// This file is generated by the 'node-soap-servicegenerator'\r\n",
                "// visit : https://github.com/BreeeZe/node-soap-servicegenerator for more info\r\n\r\n"].join('');
    
    console.log("wsdl loaded");
    for (var serviceName in WSDL.services)
        code += generateService(serviceName, WSDL.services[serviceName], tab);
    
    console.log("Writing to : %s", outputPath);
    fs.writeFile(outputPath, code, function (err) {
        if (err) {
            console.log(err);
            process.exit(1);
        }
        console.log('Done!');
        process.exit(0);
    });
});

var generateService = function (name, service, indent) {
    var code = "";
    console.log("Generating %s", name);
    for (var portName in service.ports)
        code += generatePort(portName, service.ports[portName], indent + tab);
    
    return util.format(["var %s = {\r\n",
                       indent, "%s : {\r\n",
                       "%s",
                       indent, "}\r\n",
                       "}\r\n"].join(''), name, name , code);
}

var generatePort = function (name, port, indent) {
    var code = "";
    for (var methodName in port.binding.methods)
        code += generateMethod(methodName, port.binding.methods[methodName], indent + tab);
    
    return util.format([indent, "%s : {\r\n",
                       "%s",
                       indent, "}\r\n"].join('') , name, code);
}

var generateMethod = function (name, method, indent) {
    var input = generateParameter(method.input.$name, WSDL.findParameterObject(method.input.targetNamespace, method.input.$type || method.input.$name), indent);
    var output = generateParameter(method.output.$name, WSDL.findParameterObject(method.output.targetNamespace, method.output.$type || method.output.$name), indent + tab);
    return util.format([indent, "/*%s*/\r\n",
                       indent, "%s : function(args) {\r\n",
                       indent, tab, "/*%s\r\n",
                       indent, tab, "return %s;*/\r\n",
                       indent, "},\r\n\r\n"].join(''), input, name, output, method.output.$name);
}

var generateParameter = function (name, object, indent) {
    var code = "";
    
    if (object.$lookupTypes[0])
        object = WSDL.findParameterObject(object.$lookupTypes[0].$namespace || object.targetNamespace, object.$lookupTypes[0].$type || object.$lookupTypes[0].$name)
    
    var properties = findProperties(object);
    var recursioncount = 0;
    for (var c = 0; c < properties.length; c++)
        code += generateProperties(properties[c], indent + tab, recursioncount, name);
    return util.format("var %s = { %s};", name, (code ? ["\r\n", code, indent].join('') : ""));
}

var generateProperties = function (object, indent, recursioncount, path) {
    var code = "";
    if (recursioncount > maxrecursion) {
        console.log("ABORTED !! Maximum recursion exceeded on generating property : '%s' of type : '%s', path : %s", object.name, object.type.$name, path);
        process.exit(-1);
    }
    if (!object.type.$type && ignoredTypes.indexOf(object.type.$name) == -1) {
        var properties = findProperties(object.type);
        for (var c = 0; c < properties.length; c++)
            code += generateProperties(properties[c], indent + tab, recursioncount++, path + ">" + object.name);
        return util.format([indent, "%s : { %s},\r\n"].join(''), object.name, (code ? ["\r\n", code, "\r\n", indent].join('') : ""));
    }
    return util.format([indent, "%s : %s, \r\n"].join(''), object.name, (object.type.$type ? object.type.$type.substr(object.type.$type.indexOf(':') + 1) : "null"));
}

var findProperties = function (object) {
    var result = [];
    var itterate = function (o) {
        if (o.$type)
            return o;
        for (var c = 0; c < o.children.length; c++) {
            var t = itterate(o.children[c]);
            if (t) {
                var childNamespace = t.$type.substr(0, t.$type.indexOf(':'));
                result.push({ name : t.$name, type : WSDL.findChildParameterObjectFromSchema(t.$type.substr(t.$type.indexOf(':') + 1), WSDL.definitions.xmlns[childNamespace]) || t });
            }
        }
    }
    if (object)
        itterate(object);
    return result;
}